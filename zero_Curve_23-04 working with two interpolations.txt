import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import date
import json
import statistics
import math
from datetime import date, timedelta
import scipy.interpolate as inter
from scipy.interpolate import UnivariateSpline
today = pd.to_datetime(date.today())

pd.set_option('display.max_rows', None)
pd.set_option('display.max_colwidth', None)
pd.set_option('display.width', None)
pd.set_option('display.max_columns', None)
pd.options.mode.chained_assignment = None


#   The following programme extracts from a list of italian BTPs and creates a new list of cashflows made by all coupons
#   and notional payments from each bond of the list. It then uses a spline interpolation based on the market yield to
#   maturities of zero-coupon bonds from the list to create a spot curve for all bonds up to the last zero-coupon bond
#   present on the italian curv (currently the IT0005454241 08/26). For cashflows after this maturity, a standard bootstripping
#   method is used.

#Useful resources: https://quant.stackexchange.com/questions/3302/deriving-spot-rates-from-treasury-yield-curve

def main():


    bondData = pd.read_excel("C:/Users/glenn.regis/Documents/Spreadsheets/Italy Bond Live Database.xlsx",parse_dates=True)
    bondData['Maturity'] = pd.to_datetime(bondData['Maturity'])
    #Drop first bond as it's usually volatile
    #bondData = bondData.iloc[1:].reset_index(drop=True)

    #Count Bonds
    for i in range(0,len(bondData)):
        if isinstance(bondData['ISIN'][i],float) == True:
            nBonds = i
            break


    bondData['Next Coupon'] = pd.to_datetime(bondData['Next Coupon'])

    keys = bondData.keys()
    bondDatabase = pd.DataFrame(columns=keys)
    ttm = []
    x = 0

    #Following for loop creates the bondDatabase as a list of cashflows given by all coupons of all bonds.
    #If a bond has coupons, it will calculate relevant maturity
    for i in range(0,nBonds):
        if bondData['Coupon'][i] == 0:
            bondDatabase = pd.concat([bondDatabase,bondData.iloc[[i]]], ignore_index=True)
            bondDatabase["cfMat"] = bondDatabase["Maturity"]
        else:
            coupList = couponCalculator(bondData.iloc[[i]],i)
            oneCoup = False
            if len(coupList) == 1:
                oneCoup = True

            for j in range(0,len(coupList)):
                tempBond = bondData.loc[[i]]
                newTtm = (coupList[j] - today)
                newTtm = (newTtm.days / 365)
                tempBond["Ttm"] = newTtm
                tempBond["cfMat"] = coupList[j]
                endList = len(coupList) - 1
                if oneCoup:
                    tempBond["Coupon"] = tempBond["Coupon"] / 2 * 100 + 100
                else:
                    if j < endList:
                        tempBond["Coupon"] = tempBond["Coupon"] / 2 * 100
                        tempBond["YTM"] = np.nan
                    else:
                        tempBond["Coupon"] = tempBond["Coupon"] / 2 * 100 + 100
                        tempBond["YTM"] = np.nan
                bondDatabase = pd.concat([bondDatabase, tempBond], ignore_index=True)
    bondDatabase = bondDatabase.sort_values(by=['Ttm','YTM'],ignore_index=True)
    initialParCurve = bondDatabase
    print(bondDatabase)
    plt.scatter(initialParCurve['Ttm'], initialParCurve['YTM'], label='Initial Spot curve', s=4)
    plt.axis([0, 55, -0.01, 0.05])
    plt.show()

    cashFlows = len(bondDatabase)
    bondDatabase.rename(columns = {'YTM':'Spot'}, inplace= True)
    #clean the data
    bondDatabase = yieldCleaning(bondDatabase,cashFlows)
    bondDatabase, lastPureZC = interpolation(bondDatabase,cashFlows)
    start = 0
    end = lastPureZC
    yieldCalculator(bondDatabase,start,end)
    lastBond = lastPureZC
    flag = True
    end = False
    while lastBond < cashFlows and not end:
        lastPureZC, currLastBond,newBondSet,end = nextSet(bondDatabase,cashFlows,lastBond,end)
        bondDatabase, newLastBond,flag,end = rollingInterp(bondDatabase,lastPureZC,currLastBond,newBondSet,flag,end)
        lastBond = newLastBond


    plt.scatter(bondDatabase['Ttm'], bondDatabase['Spot'], label='spot curve', color='r')
    plt.scatter(bondData['Ttm'], bondData['YTM'], label='YTM curve',color='g')
    #plt.scatter(initialParCurve['Ttm'], initialParCurve['YTM'], label='Initial spot curve', s=4)
    plt.axis([0, 55, -0.01, 0.05])
    plt.show()


def couponCalculator(myBond,i):
    myCoupList = []
    maturity = myBond["Maturity"][i]
    lastSemester = myBond["Maturity"][i] - timedelta(days=180)
    if myBond["Next Coupon"][i] == myBond["Maturity"][i]:
        myCoupList.append(maturity)
        return myCoupList
    else:
        daysToMat = (myBond["Maturity"][i]-today)
        nOfCoupons = math.ceil(daysToMat.days / 180)
        #We calculate days and months of the first coupon so we can apply same days and months for all future coupons
        curDate = myBond["Next Coupon"][i]
        coupDay = myBond["Next Coupon"][i].day
        coupMonth = myBond["Next Coupon"][i].month
        counter = 0
        #we create the list of coupon dates
        while curDate < lastSemester:
            if (counter % 2) == 0:
                curDate = curDate.replace(day=coupDay,month=coupMonth)
            counter += 1
            myCoupList.append(curDate)
            curDate += timedelta(days=180)
        myCoupList.append(maturity)

    return myCoupList

def yieldCleaning(bondDatabase,cashFlows):
    #Looks for CFs with same maturity and applies the correct spot rate
    for i in range(0,cashFlows):
        if bondDatabase["Ttm"][i] in bondDatabase["Ttm"][:i].values:
            bondDatabase["Spot"][i] = bondDatabase["Spot"][i-1]
    return bondDatabase


def interpolation(bondDatabase, cashFlows):
    originalVals = bondDatabase[bondDatabase.Spot.notnull()]
    #remove duplicates
    originalVals = originalVals.drop_duplicates(subset=['Ttm'])
    #We take drop the first value because it is volatile
    #originalVals = originalVals[1:]
    #Finds last pure market zero-coupon
    lastPureZC = originalVals.last_valid_index()
    #I define the last zero coupon beyond which there is too much room and I will interpolate with another interpolation
    #method
    lastShortZeroCoupon = 6
    lastShortZeroCouponIndex = originalVals.index[lastShortZeroCoupon-1]

    originalVals = originalVals.reset_index()
    #Split Zero coupon bonds in two: first batch has Ttm<1, second Ttm >1
    a = originalVals['Ttm'].to_numpy()
    b = originalVals['Spot'].to_numpy()
    aShort = a[:lastShortZeroCoupon]
    bShort = b[:len(aShort)]
    aLong = a[lastShortZeroCoupon-1:]
    bLong = b[-len(aLong):]
    #Here we can use two splines: spline is an interpolation that goes through all points. Univariate Spline instead
    # has a wider degree of freedom
    spline = inter.InterpolatedUnivariateSpline(aShort, bShort)
    regSpline = inter.UnivariateSpline(aLong, bLong)

    # myX = np.linspace(0,0.68,100)
    # myX2 = np.linspace(0.68,8,100)
    # plt.plot(myX, spline(myX), label='firsthalf')
    # plt.plot(myX2, regSpline(myX2), 'k--', label='firsthalf')
    # plt.axis([4, 5, -0.01, 0.01])
    # plt.scatter(originalVals['Ttm'], originalVals['Spot'])
    # plt.show()

    for i in range(0,lastPureZC):
        if pd.isnull(bondDatabase.iloc[i]['Spot']) and bondDatabase.iloc[i]['Coupon'] < 100:
            if (i < lastShortZeroCouponIndex):
                y = spline(bondDatabase.iloc[i]['Ttm'])
            else:
                y = regSpline(bondDatabase.iloc[i]['Ttm'])
            bondDatabase['Spot'][i] = y
    #print(bondDatabase)

    # x2 = np.linspace(0, 4, 100)
    #
    # plt.axis([4, 5, -0.01, 0.03])
    # plt.scatter(a,b)
    # plt.plot(bondDatabase['Ttm'], bondDatabase['Spot'], color='r')
    # plt.plot(x2, regSpline(x2), color="r")
    # plt.show()
    return bondDatabase, lastPureZC

def nextSet(bondDatabase,cashFlows,lastPureZC,end):
    #I take all the bonds which I haven't calculated Spot yields for and which have yields for all their CFs
    remaining = cashFlows - lastPureZC
    print("My remaining bond is ", remaining)
    #Finds latest available maturity for which we have a Spot rate
    currentMaturity = bondDatabase['cfMat'][lastPureZC]
    print("My currentMaturity is is ", currentMaturity)
    set = bondDatabase.tail(remaining-1)
    set = set[set['Coupon']>100]
    print("My set is")
    print(set)
    keys = set.keys()
    newBondSet = pd.DataFrame(columns=keys)
    for i in range(0,len(set)):
        myIndex = set.index[i]
        myCoupList = couponCalculator(set.iloc[[i]],myIndex)
        secLastCoupDate = myCoupList[-2]
        print("My coupons are")
        print(myCoupList)
        print(secLastCoupDate)
        print(type(secLastCoupDate))
        print(currentMaturity)
        print(type(currentMaturity))
        if secLastCoupDate > currentMaturity:
            break
        else:
            #Calls the yield calculator on bonds and then returns the last bond so as to reinstate the loop
            myLastBond = yieldCalculator(bondDatabase,lastPureZC,myIndex+1)
            print("Bond I just calculated yield for was ")
            print(myLastBond)
            #creates a set with the newly calculated bonds which I will then add
            newBondSet = pd.concat([newBondSet,bondDatabase.iloc[[myIndex]]], ignore_index=True)
            print("This is my new bond set")
    if newBondSet.empty:
        print("Set is empty")
        lastBond = lastPureZC
        #adding a flag to tell me that I'm calling the interpolation when there is no data ahead
        flag = False
        bondDatabase, myLastBond,flag,end = rollingInterp(bondDatabase,lastPureZC,lastBond,newBondSet,flag,end)
        flag = True
        #I call nextset again so that I don't have a repetition by calling rolling interpo again
        if not end:
            lastPureZC, myLastBond,newBondSet,end = nextSet(bondDatabase,cashFlows,myLastBond,end)
    print("Have I just entered?")
    newBondSet = newBondSet.sort_values(by=['Ttm','Spot'],ignore_index=True)
    print("this is new bond set")
    print(newBondSet)
    print("I am returning my set and my last zero coupon is ", lastPureZC, " while my last bond is ",myLastBond)
    return lastPureZC, myLastBond, newBondSet,end



def rollingInterp(bondDatabase,lastPureZC,lastBond,newBondSet,flag,end):
    print("My end is ",end)
    print("I'm in rolling interpolation and my range is", lastPureZC," and ", lastBond)
    print("My last zero database is")
    lastZeroDatabase = bondDatabase.head(lastPureZC)
    lastZeroDatabase = lastZeroDatabase[lastZeroDatabase['Coupon'] > 100]

    print(lastZeroDatabase)
    firstBond = lastZeroDatabase.head(1)
    row1 = lastZeroDatabase.tail(15).head(1)
    row2 = lastZeroDatabase.tail(7).head(1)
    row3 = lastZeroDatabase.tail(1)
    lastZeroDatabase = pd.concat([row1,row2,row3], axis=0)
    #lastZeroDatabase = lastZeroDatabase.tail(5)
    print("This is my last 3 bonds")
    print(lastZeroDatabase)
    print("And this is my new bond set")
    print(newBondSet)
    if newBondSet.empty:
        #Setting a flag which tells us we're interpolating beyond the realm of known bonds
        furtherInterpoFlag = True
        lastPureZC = lastBond
        lastBond = lastBond + 20
        if lastBond>=len(bondDatabase):
            end = True
            lastBond = len(bondDatabase)
        print("Set is empty and my last bond is")
        print(lastBond)
        print("My last pure ZC is")
        print(lastPureZC)
    interpSet = pd.concat([newBondSet,lastZeroDatabase], axis=0)
    #interpSet = pd.concat([interpSet,firstBond], axis=0)
    interpSet = interpSet.sort_values(by=['Ttm','Spot'],ignore_index=True)
    print("My last bond for the currentT is ", lastBond)
    #I calculate what Ttm I'm at, so that I can calculate my current Ttm which I'll then need when deciding what interpolation to use
    myTBond = lastBond
    if myTBond >= len(bondDatabase):
        currentT = bondDatabase.iloc[len(bondDatabase)-1]['Ttm']
    else:
        currentT = bondDatabase.iloc[lastBond]['Ttm']
    print("And this is my full interpolation set")
    print(interpSet)
    a = interpSet['Ttm'].to_numpy()
    b = interpSet['Spot'].to_numpy()

    regSpline = inter.UnivariateSpline(a, b,s=0.05,k=2)
    linSpline = inter.UnivariateSpline(a, b, s=3,k=1)

    myX = np.linspace(0,30,100)
    plt.plot(myX, regSpline(myX), 'k--', label='sec Interp')
    plt.axis([0, 40, -0.01, 0.05])
    plt.scatter(lastZeroDatabase['Ttm'], lastZeroDatabase['Spot'])
    plt.show()

    #If Ttm>20, use linea interpo, otherwise use polynomial with k=2

    for i in range(lastPureZC,lastBond):
        if pd.isnull(bondDatabase.iloc[i]['Spot']) and bondDatabase.iloc[i]['Coupon'] < 100 and flag:
            # If Ttm>20, use linea interpo, otherwise use polynomial with k=2
            if currentT > 20:
                y = linSpline(bondDatabase.iloc[i]['Ttm'])
            else:
                y = regSpline(bondDatabase.iloc[i]['Ttm'])
            bondDatabase['Spot'][i] = y
        if pd.isnull(bondDatabase.iloc[i]['Spot']) and not flag:
            if currentT > 20:
                y = linSpline(bondDatabase.iloc[i]['Ttm'])
            else:
                y = regSpline(bondDatabase.iloc[i]['Ttm'])
            bondDatabase['Spot'][i] = y
    print(bondDatabase)

    x2 = np.linspace(0, 4, 100)
    plt.scatter(a,b)
    plt.plot(bondDatabase['Ttm'], bondDatabase['Spot'], color='r')
    plt.show()

    #If set is empty, telling it that the new last bond is one previous. This is because if set is empty, it will only
    #interpolate excluding the last bond, therefore I have to tell him to take the previous one when checking
    if newBondSet.empty and not end:
        lastBond = lastBond - 1
    if not end:
        lastBond = checkSet(bondDatabase, lastPureZC, lastBond)
    flag = True
    print("Returning end ", end)
    return bondDatabase, lastBond,flag,end

def checkSet(bondDatabase,lastPureZC, myLastBond):
    print("Entered checkSet")
    print("My range beforehand is ", lastPureZC,myLastBond)

    lastTtm = bondDatabase['Ttm'][myLastBond]
    lastSpot = bondDatabase['Spot'][myLastBond]
    for i in range(myLastBond+1,myLastBond+20):
        currentTtm = bondDatabase['Ttm'][i]
        if currentTtm == lastTtm:
            bondDatabase['Spot'][i] = lastSpot
            myLastBond = i
        else:
            break
    print("My range after is ", lastPureZC,myLastBond)
    return myLastBond

def yieldCalculator(bondDatabase,start,end):
    print("My start is ", start, " and my end is ", end)
    #loops through bonds and calls spot rate calculator to calculate rates
    for i in range(start,end):
        if bondDatabase.iloc[i]['Coupon'] > 100:
            isin = bondDatabase.iloc[i]['ISIN']
            #creates a list of cashflows of the bond thanks to group by isin
            bondCFs = bondDatabase[bondDatabase['ISIN'] == isin]
            #checks to see whether in the list of cashflows there is only one whose yield is to be calculated
            if (bondCFs.Spot.isnull()).sum() == 1:
                myYield = spotCalculator(bondCFs)
                bondDatabase['Spot'][i] = myYield

    print("This is my final bond database", bondDatabase)
    #plt.axis([4, 5, -0.01, 0.03])
    #plt.scatter(bondDatabase['Ttm'], bondDatabase['Spot'])
    #plt.show()
    #returning the last bond whose yield has been calculated
    return i

def spotCalculator(bondCFs):
    nCFs = len(bondCFs)
    finalCashFlow = bondCFs.iloc[nCFs-1]['Coupon']
    maturity = bondCFs.iloc[nCFs-1]['Ttm']
    dirtyPrice = bondCFs.iloc[nCFs-1]['Dirty Price']
    sumDiscCFs = 0
    for i in range(0,nCFs-1):
        period = bondCFs.iloc[i]['Ttm']
        sumDiscCFs +=  (bondCFs.iloc[i]['Coupon']) / (1+bondCFs.iloc[i]['Spot'])**(bondCFs.iloc[i]['Ttm'])
        print(sumDiscCFs)
    print("My finalCashFlow is ", finalCashFlow)
    print("My dirty price is ", dirtyPrice)
    print("My maturity is ", maturity)
    spot = ((finalCashFlow/(dirtyPrice - sumDiscCFs))**(1/(maturity))-1)
    return spot

main()